ItemTypeMap = {
    book1 = {
        "book_rocky",     --石虾
        "book_pigman",    --猪人
        "book_bunnyman",  --兔人
        "book_krampus",   --坎普斯
        "book_tentacles", --触手
        "book_birds",
        "book_meteor",
        "book_sleep",
        "book_brimstone"
    },
    book2 = {
        "book_minotaur",          --犀牛
        "book_deerclops",         --巨鹿
        "book_moose",             --鸭子
        "book_dragonfly",         --龙蝇
        "book_bearger",           --熊大
        "book_spiderqueen",       --蜘蛛女王
        "book_leif",              --树精
        "book_touch_leif",        --点树成精
        "book_touch_spiderqueen", --点蛛成精
        "book_animal_breed",      --生物繁殖书
        "book_grow_spiderden",    --蜘蛛生长
    },
    book3 = {
        "book_clear",           --清理书
        "book_harvest",         --收获书
        "book_pickup",          --拾取书
        "book_seeder",          --播种书
        "book_hatch",           --孵化书
        "book_gardening",       --应用园艺学
        "book_incubate",        --应用孵化学
        "book_pisciculture",    --应用渔业学
        "book_pigman_golden",   --猪人点金
        "book_bunnyman_golden", --兔人点金
        "book_golden_rocky",    --黄金石虾
        "book_touch_golden",    --点怪成金书
        "book_seeder_golden",   --黄金播种书
    },
    golden_food = TaxueList.golden_food,
    gem = {
        "redgem",        --红
        "bluegem",       --蓝
        "purplegem",     --紫
        "greengem",      --绿
        "orangegem",     --橙
        "yellowgem",     --黄
        "pink_gem",      --粉宝石
        "cyan_gem",      --青宝石
        "white_gem",     --白宝石
        "black_gem",     --黑宝石
        "taxue_diamond", --钻石

        "random_gem",    --随机宝石
        "promote_gem",   --提升宝石
        "reset_gem",     --重置宝石
        "colorful_gem",  --五彩宝石
        "copy_gem",      --复制宝石
    },
    equipment = TaxueList.equipment,
    my_ticket = TaxueList.my_ticket,
    egg_all = {
        "taxue_egg_nomal",
        "taxue_egg_moose",
        "taxue_egg_doydoy",
        "taxue_egg_tallbird",
        "taxue_egg_colourful",
        "taxue_egg_golden",
        "taxue_egg_sakura",
        "taxue_egg_lacy",
        "taxue_egg_taxue",
        "taxue_egg_totoro",
        "taxue_egg_spotty",
        "taxue_egg_wave",
        "taxue_egg_star",
        "taxue_egg_grassland",
        "taxue_egg_lightning",
        "taxue_egg_whiteblue",
        "taxue_egg_strawberry",
        "taxue_egg_pineapple",
        "taxue_egg_lollipop",
        "taxue_egg_starrysky",
        "taxue_egg_tigershark",
        "taxue_egg_charm",
        "taxue_egg_eddy",
        "taxue_egg_txxm",
        "taxue_egg_hatch",
        "taxue_egg_delicious",
        "taxue_egg_porcelain",
        "taxue_egg_rainbow",
        "taxue_egg_lava",
        "taxue_egg_decorate",
        "taxue_egg_harvest",
        "taxue_egg_lollipop_rare",
        "taxue_egg_ancient",
        "taxue_egg_skin",
        "taxue_egg_melon",
        "taxue_egg_rock",
        "taxue_egg_meteor",
        "taxue_egg_millionclub",
        "taxue_egg_rose",
        "taxue_egg_ampullaria_gigas",
        "taxue_egg_free",
    },
    treasure_map = TaxueList.treasure_map,
    weapon1 = TaxueList.weapon,
    weapon2 = TaxueList.weapon2,
    armor1 = TaxueList.armor,
    armor2 = TaxueList.armor_2,
    key = {

        "corkchest_key",     --软木桶钥匙
        "treasurechest_key", --木箱钥匙
        "skullchest_key",    --骨钥匙
        "pandoraschest_key", --精致钥匙
        "minotaurchest_key", --豪华钥匙
        "terrarium_key",     --恐怖钥匙
        "poison_key",        --剧毒钥匙
    },
    agentia_all = {
        "exp_agentia",             --经验药剂-蓝
        "health_agentia",          --血量药剂-红
        "sanity_agentia",          --san值药剂-绿
        "ice_agentia",             --寒冰药剂
        "hot_agentia",             --炎热药剂
        "map_agentia",             --开心
        "treasure_agentia",        --寻宝
        "totoro_agentia",          --龙猫
        "transfer_agentia",        --随机传送
        "light_agentia",           --发光药剂

        "antivenom_agentia",       --解毒药剂
        "sleep_agentia",           --催眠药水
        "invisible_agentia",       --隐形药水
        "taxue_milk",              --牛奶

        "golden_agentia_pigman",   --点金猪人
        "golden_agentia_bunnyman", --点金兔人
        "scared_agentia",          --恐惧药剂
        "mocking_agentia",         --嘲讽药剂
        "awake_agentia",           --唤醒药剂
        "lessen_agentia",          --缩小药剂
        "paralytic_agentia",       --麻痹药剂
        "bleed_agentia",           --流血药剂
        "weak_agentia",            --虚弱药剂
        "rage_agentia",            --狂暴药剂
        "illegal_cooking_oil",     --地沟油
        "bramble_agentia",         --荆棘药剂
        "bloodsucking_agentia",    --嗜血药剂
    },
    essence = {
        "plant_essence",         --植物精华
        "sea_essence",           --海洋精华
        "volcano_essence",       --火山精华
        "threecolor_essence",    --三色精华
        "delicious_essence",     --美味精华
        "roe_essence",           --鱼籽精华
        "pearl_essence",         --珍珠精华
        "spiderhat_essence",     --蜘蛛帽精华
        "mineral_essence",       --矿石精华
        "mushroom_essence",      --蘑菇精华
        "ice_essence",           --寒冰精华
        "return_fresh_essence",  --反鲜精华
        "free_essence",          --白嫖精华
        "free_essence_advanced", --高级白嫖精华
        "chest_essence",         --宝箱精华
        "chest_essence_nomal"    --稀有宝箱精华
    },
    special = {
        "perpetual_core",     --永动机核心
        "crystal_ball_taxue", --水晶煤球
        "random_agentia",     --随机药剂
        "chest_agentia",      --宝箱药剂
    },
}

ItemTypeNameMap = {
    book1 = "低级书",
    book2 = "高级书",
    book3 = "功能书",
    golden_food = "黄金食物",
    gem = "宝石",
    equipmentHigh = "高属性五彩装备",
    equipmentLow = "低属性五彩装备",
    my_ticket = "劵类",
    egg_all = "孵化蛋",
    treasure_map = "藏宝图",
    weapon1 = "低级武器",
    weapon2 = "高级武器",
    armor1 = "低级装备",
    armor2 = "高级装备",
    key = "钥匙",
    agentia_all = "药水",
    essence = "精华",
    special = "特殊",
    others = "其他"
}

ItemDataMap = {
    refreshticket_ticket = "refresh_num",          --刷券券
    loot_ticket = "loot_multiple",                 --战利品券
    book_touch_leif = "leif_num",                  --点树成精
    book_touch_spiderqueen = "spiderqueen_num",    --点蛛成精
    book_touch_golden = "golden_num",              --点怪成金
    gamble_ticket = "gamble_multiple",             --赌狗劵
    substitute_ticket = "substitute_item",         --掉包券
    shop_refresh_ticket_directed = "refresh_item", --定向商店刷新券
    interest_ticket = "interest"                   --利息券
}

DataStrMap = {
    refreshticket_ticket = "可刷新数量：%s个", --刷券券
    loot_ticket = "额外掉落：%s倍", --战利品券
    book_touch_leif = "树精数量: %s只", --点树成精
    book_touch_spiderqueen = "蜘蛛女王数量: %s只", --点蛛成精
    book_touch_golden = "点金数量: %s只", --点怪成金
    gamble_ticket = "额外掉落: %s倍", --赌狗劵
    substitute_ticket = "掉包物品: %s", --掉包券
    shop_refresh_ticket_directed = "刷新物品: %s", --定向商店刷新券
    interest_ticket = "利息上限: %s梅币" --利息券
}

local cfg = TaxuePatch.cfg

---count table
---@param table table
---@return integer
TableCount = function(table)
    local count = 0
    for _, _ in pairs(table) do count = count + 1 end
    return count
end
table.TableCount = TableCount

---测试物品是否符合条件
---@param item table
---@param test string|string[]|fun(table:table):boolean
---@return boolean
function TestItem(item, test)
    if not item then return false end
    local testFn
    if type(test) == "table" then
        testFn = function(prefab) return table.contains(test, prefab.prefab) end
    elseif type(test) == "string" then
        testFn = function(prefab) return prefab.prefab == test end
    elseif type(test) == "function" then
        testFn = test
    else
        return false
    end
    return testFn(item)
end

---返回slots中找到的第一个符合的物品
---@param slots table[]
---@param itemTest string|string[]|fun(table:table):boolean
---@return table|nil item
---@return integer|nil slot
function FindItem(slots, itemTest)
    if not slots then return nil, nil end
    for slot, item in pairs(slots) do
        if TestItem(item, itemTest) then
            return item, slot
        end
    end
end

---查找周围实体
---@param inst table
---@param radius number
---@param testFn? fun(entity: table): boolean
---@param tags? string[]
---@param notags? string[]
---@return table[]
function GetNearByEntities(inst, radius, testFn, tags, notags)
    if not inst or not inst:IsValid() then return {} end
    local pos = Vector3(inst.Transform:GetWorldPosition())
    local notags = notags or { "INLIMBO", "NOCLICK", "catchable", "fire", "player" }
    local list = {}
    local ents = TheSim:FindEntities(pos.x, pos.y, pos.z, radius, tags, notags)
    for _, entity in pairs(ents) do
        if entity ~= inst and entity:IsValid() and (not testFn or testFn(entity)) then
            table.insert(list, entity)
        end
    end
    return list
end

---计算概率次数结果
---@param chance number
---@param times integer
---@return integer
function GetChanceResult(chance, times)
    local result = 0
    for _ = 1, times do
        if math.random() < chance then
            result = result + 1
        end
    end
    return result
end

TaxuePatch.GetChanceResult = GetChanceResult

local function giveItem(inst, item)
    local owner = inst.components.inventoryitem.owner
    if owner then
        local container = owner == GetPlayer() and owner.components.inventory or owner.components.container
        if container:CanTakeItemInSlot(item) then
            container:GiveItem(item)
            return
        end
    end
    local pos = Vector3(inst.Transform:GetWorldPosition())
    item.Transform:SetPosition(pos:Get())
    item.components.inventoryitem:OnDropped(true)
end

local function getStackedItem(name, amount, maxsize)
    local items = {}
    if not maxsize then
        local tempItem = SpawnPrefab(name)
        maxsize = tempItem.components.stackable.maxsize
        tempItem:Remove()
    end
    local size = amount or 1
    local stack_num = math.floor(size / maxsize)
    local surplus_num = size - maxsize * stack_num
    if stack_num > 0 then
        for i = 1, stack_num do
            local newItem = SpawnPrefab(name)
            newItem.components.stackable.stacksize = maxsize
            table.insert(items, newItem)
        end
    end
    if surplus_num > 0 then
        local newItem = SpawnPrefab(name)
        newItem.components.stackable.stacksize = surplus_num
        table.insert(items, newItem)
    end
    return items
end

local function addToList(list, entity, number, data)
    local amount = 1
    local name = entity
    if type(entity) == "string" then
        amount = number or 1
    else
        name = entity.prefab
        amount = entity.components.stackable and entity.components.stackable.stacksize or 1
    end
    if type(entity) == "string" or entity.components.stackable then
        list[name] = list[name] and list[name] + amount or amount
    else
        list[name] = list[name] or {}
        local listItem = list[name]
        if data then
            list[name][data] = list[name][data] or {}
            listItem = list[name][data]
        end
        local saveData = entity:GetSaveRecord()
        table.insert(listItem, saveData)
    end
end

local function processPackageData(package, itemType, itemName, amount, value, data)
    package.amount = package.amount or 0
    package.amount = amount and package.amount + amount or package.amount

    package.amountMap = package.amountMap or {}
    package.amountMap[itemType] = package.amountMap[itemType] or { amount = 0, sub = {} }
    local aIndex = package.amountMap[itemType]
    aIndex.amount = amount and aIndex.amount + amount or aIndex.amount

    if package.hasValue == nil then package.hasValue = true end
    package.hasValue = package.hasValue and (value ~= nil)
    if package.hasValue then
        package.taxue_coin_value = package.taxue_coin_value and package.taxue_coin_value + value or value
    else
        package.taxue_coin_value = nil
    end

    package.valueMap = package.valueMap or {}
    package.valueMap[itemType] = package.valueMap[itemType] or { hasValue = true, value = 0, sub = {} }
    local vIndex = package.valueMap[itemType]
    vIndex.hasValue = vIndex.hasValue and (value ~= nil)
    vIndex.value = value and vIndex.value + value or vIndex.value

    for _, i in pairs({ itemName, data }) do
        if i then
            aIndex.sub = aIndex.sub or {}
            aIndex.sub[i] = aIndex.sub[i] or { amount = 0 }
            aIndex = aIndex.sub[i]

            aIndex.amount = amount and aIndex.amount + amount or aIndex.amount

            vIndex.sub = vIndex.sub or {}
            vIndex.sub[i] = vIndex.sub[i] or { hasValue = true, value = 0 }
            vIndex = vIndex.sub[i]

            vIndex.hasValue = vIndex.hasValue and (value ~= nil)
            vIndex.value = value and vIndex.value + value or vIndex.value
        end
    end
end

---spawn a super package
---@param name? string package display name
---@param type? string|nil package type
---@return table package
function SpawnPackage(name, type)
    local package = SpawnPrefab("super_package")
    package.isPatched = true
    package.name = name or package.name
    package.type = type
    package.amount = 0
    package.amountMap = {}
    package.hasValue = true
    package.valueMap = {}
    return package
end

---transform package to patched package
---@param package table
---@return table newPackage
function TransformPackage(package)
    local slots = package.components.container.slots
    local newPackage = SpawnPackage()
    for _, v in pairs(slots) do
        AddItemToSuperPackage(newPackage, v)
    end
    for k, v in pairs(package.item_list) do
        if type(v) == "table" then
            for name, items in pairs(v) do
                if type(items) == "number" then
                    local item = SpawnPrefab(name)
                    item.components.stackable.stacksize = items
                    AddItemToSuperPackage(newPackage, item)
                else
                    for _, itemData in pairs(items) do
                        if itemData.prefab then
                            local item = SpawnSaveRecord(itemData)
                            AddItemToSuperPackage(newPackage, item)
                        else
                            for _, itemData in pairs(itemData) do
                                local item = SpawnSaveRecord(itemData)
                                AddItemToSuperPackage(newPackage, item)
                            end
                        end
                    end
                end
            end
        else
            local newItem = SpawnPrefab(k)
            newItem.components.stackable.stacksize = v
            AddItemToSuperPackage(newPackage, newItem)
        end
    end
    if TableCount(newPackage.item_list) == 1 then
        for type, _ in pairs(newPackage.item_list) do
            newPackage.type = type
        end
    end
    local owner = package.components.inventoryitem.owner
    if owner then
        newPackage.components.inventoryitem.owner = owner
        local container, slots
        if owner == GetPlayer() then
            container = owner.components.inventory
            slots = container.itemslots
        else
            container = owner.components.container
            slots = container.slots
        end
        for i, item in pairs(slots) do
            if item == package then
                container:RemoveItemBySlot(i)
                container:GiveItem(newPackage, i)
                break
            end
        end
    else
        newPackage.Transform:SetPosition(Vector3(package.Transform:GetWorldPosition()):Get())
    end
    package:Remove()
    return newPackage
end

---merge two packages into one
---@param package table
---@param packageM table
---@return table package
function MergePackage(package, packageM)
    if not package.isPatched then package = TransformPackage(package) end
    if not packageM.isPatched then packageM = TransformPackage(packageM) end
    if packageM.amount == 0 then return package end

    local item_list = package.item_list
    for itemType, list1 in pairs(packageM.item_list) do
        item_list[itemType] = item_list[itemType] or {}
        for itemName, list2 in pairs(list1) do
            if type(list2) == "table" then
                item_list[itemType][itemName] = item_list[itemType][itemName] or {}
                for data, list3 in pairs(list2) do
                    if list3.prefab then
                        table.insert(item_list[itemType][itemName], list3)
                        local value = packageM.valueMap[itemType].sub[itemName].hasValue and packageM.valueMap[itemType].sub[itemName].value / #list2 or nil
                        processPackageData(package, itemType, itemName, 1, value)
                    else
                        for _, item in pairs(list3) do
                            item_list[itemType][itemName][data] = item_list[itemType][itemName][data] or {}
                            table.insert(item_list[itemType][itemName][data], item)
                            local value = packageM.valueMap[itemType].sub[itemName].hasValue and packageM.valueMap[itemType].sub[itemName].sub[data].value / #list3 or nil
                            processPackageData(package, itemType, itemName, 1, value, data)
                        end
                    end
                end
            else
                item_list[itemType][itemName] = item_list[itemType][itemName] and item_list[itemType][itemName] + list2 or list2
                local value = packageM.valueMap[itemType].sub[itemName].hasValue and packageM.valueMap[itemType].sub[itemName].value or nil
                processPackageData(package, itemType, itemName, list2, value)
            end
        end
    end
    packageM:Remove()
    return package
end

---将物品添加到超级包裹
---@param package table
---@param entity table
---@param showFx? boolean
function AddItemToSuperPackage(package, entity, showFx)
    --特效
    if showFx then SpawnPrefab("small_puff").Transform:SetPosition(entity.Transform:GetWorldPosition()) end
    --fx.Transform:SetScale(0.5,0.5,0.5)
    if not package.isPatched then
        package = TransformPackage(package)
        if not package then return end
    end

    local item_list = package.item_list
    if entity.prefab == "super_package" then
        MergePackage(package, entity)
        return
    end
    local itemType
    for type, list in pairs(ItemTypeMap) do
        if table.contains(list, entity.prefab) then
            if type == "equipment" then
                local isHigh = entity.equip_value >= cfg.HIGH_EQUIPMENT_PERCENT * entity.MAX_EQUIP_VALUE
                type = isHigh and "equipmentHigh" or "equipmentLow"
            end
            itemType = type
            break
        end
    end
    itemType = itemType or "others"
    local data
    if table.containskey(ItemDataMap, entity.prefab) then
        data = entity[ItemDataMap[entity.prefab]]
    end
    item_list[itemType] = item_list[itemType] or {}
    addToList(item_list[itemType], entity, nil, data)

    local amount = entity.components.stackable and entity.components.stackable.stacksize or 1
    local coinValue = entity.taxue_coin_value and entity.taxue_coin_value * amount

    local specialValueMap = {
        taxue_coin = 100,
        taxue_coin_silver = 1,
        taxue_coin_copper = 0.01
    }

    for name, value in pairs(specialValueMap) do
        if entity.prefab == name then
            coinValue = value * amount
            break
        end
    end

    processPackageData(package, itemType, entity.prefab, amount, coinValue, data)

    entity:Remove()
end

---打包所有实体
---@param package table
---@param entities table[]
---@param testFn function
function PackAllEntities(package, entities, testFn)
    local treasures = {}
    for _, ent in ipairs(entities) do
        if cfg.OPEN_TREASURES and ent:HasTag("taxue_treasure") then
            table.insert(treasures, ent)
        elseif testFn(ent) then
            if ent:HasTag("loaded_package") and ent.loaded_item_list then
                for _, name in pairs(ent.loaded_item_list) do
                    AddItemToSuperPackage(package, SpawnPrefab(name), true)
                end
                ent:Remove()
            else
                AddItemToSuperPackage(package, ent, true)
            end
        end
    end
    if next(treasures) then
        AddTreasuresToPackage(package, treasures)
    end
    if TableCount(package.item_list) == 1 then
        local type, _ = next(package.item_list)
        package.name = ItemTypeNameMap[type]
        package.type = type
    else
        package.type = nil
        package.name = TaxueToChs(package.prefab)
    end
end

---打开超级包裹
---@param package table
---@return table|nil
function UnpackSuperPackage(package)
    if package.isPatched and package.amountMap then
        if package.amount == 0 then return nil end
        local item_list = package.item_list
        if not package.type then
            for itemType, list in pairs(item_list) do
                local typeName = ItemTypeNameMap[itemType]
                local newPackage = SpawnPackage()
                newPackage.name = typeName
                newPackage.type = itemType
                newPackage.amount = package.amountMap[itemType].amount
                newPackage.amountMap = newPackage.amountMap or {}
                newPackage.amountMap[itemType] = package.amountMap[itemType]
                newPackage.hasValue = package.valueMap[itemType].hasValue
                newPackage.valueMap = newPackage.valueMap or {}
                newPackage.valueMap[itemType] = package.valueMap[itemType]
                newPackage.taxue_coin_value = newPackage.hasValue and package.valueMap[itemType] and package.valueMap[itemType].value or nil
                newPackage.item_list[itemType] = list
                giveItem(package, newPackage)
            end
        else
            local list = package.item_list[package.type]
            local maxAmount = cfg.PACKAGE_MAX_AMOUNT
            local isSingle = TableCount(list) == 1
            for itemName, items in pairs(list) do
                local itemList = {}
                if type(items) == "number" then
                    local tempItem = SpawnPrefab(itemName)
                    local maxsize = tempItem.components.stackable.maxsize
                    tempItem:Remove()
                    itemList = getStackedItem(itemName, items, maxsize)
                else
                    local isSingleData = TableCount(items) == 1
                    local newPackage
                    for value, item in pairs(items) do
                        if item.prefab then
                            table.insert(itemList, SpawnSaveRecord(item))
                        elseif isSingleData or package.amountMap[package.type].amount < maxAmount then
                            for _, item_ in ipairs(item) do
                                table.insert(itemList, SpawnSaveRecord(item_))
                            end
                        elseif isSingle then
                            local packageName = TaxueToChs(itemName) .. "  " .. DataStrMap[itemName]:format(type(value) == "number" and value or TaxueToChs(value))
                            local newPackage = SpawnPackage(packageName, package.type)
                            for _, item_ in ipairs(item) do
                                AddItemToSuperPackage(newPackage, SpawnSaveRecord(item_))
                            end
                            giveItem(package, newPackage)
                        else
                            newPackage = newPackage or SpawnPackage(TaxueToChs(itemName), package.type)
                            for _, item_ in ipairs(item) do
                                AddItemToSuperPackage(newPackage, SpawnSaveRecord(item_))
                            end
                        end
                    end
                    if newPackage then giveItem(package, newPackage) end
                end
                local itemNum = #itemList
                if itemNum > maxAmount * 1.5 then
                    local packageName = TaxueToChs(itemName)
                    local packageType = package.type
                    local newPackage = SpawnPackage(packageName, packageType)
                    local i = 0
                    for _, item in ipairs(itemList) do
                        if isSingle then
                            if i >= maxAmount and itemNum - i > maxAmount / 2 then
                                giveItem(package, newPackage)
                                newPackage = SpawnPackage(packageName, packageType)
                                itemNum = itemNum - i
                                i = 0
                            end
                            i = i + 1
                        end
                        AddItemToSuperPackage(newPackage, item)
                    end
                    giveItem(package, newPackage)
                else
                    for _, item in pairs(itemList) do
                        giveItem(package, item)
                    end
                end
            end
        end
    else
        TransformPackage(package)
    end
    local owner = package.components.inventoryitem.owner
    if owner then
        if owner == GetPlayer() then
            owner.components.inventory:RemoveItem(package, true)
        else
            owner.components.container:RemoveItem(package, true)
        end
    end
    package:Remove()
end

---删除容器内物品
---@param container table
---@param itemList table[]
function RemoveSlotsItems(container, itemList)
    for slot, _ in pairs(itemList) do
        container:RemoveItemBySlot(slot):Remove()
    end
end

---售货亭卖东西
---@param inst table
function SellPavilionSellItems(inst)
    local container = inst.components.container
    local slots = container.slots

    local diamond = nil
    local playSound = false
    local coinList = {}
    local coins = 0
    for slot, item in pairs(slots) do
        local amount = 1
        if item and item.components.stackable then
            amount = item.components.stackable.stacksize
        end
        if item and item.taxue_coin_value then
            --物品价值
            local taxue_coin_value = item.taxue_coin_value
            --有耐久，根据耐久百分比替换价值
            if item.components.finiteuses then
                local percent = item.components.finiteuses:GetPercent()
                taxue_coin_value = taxue_coin_value * percent
            end
            --有护甲值
            if item.components.armor then
                local percent = item.components.armor:GetPercent()
                taxue_coin_value = taxue_coin_value * percent
            end

            coins = coins + taxue_coin_value * amount

            --移除物品
            container:RemoveItemBySlot(slot):Remove()
        elseif item and item.prefab == "taxue_coin" then
            coinList[slot] = item
        elseif item and item.prefab == "taxue_coin_silver" then
            coinList[slot] = item
        elseif item and item.prefab == "taxue_coin_copper" then
            coinList[slot] = item
        elseif item and cfg.SELL_PAVILION == "bank" and item.prefab == "taxue_diamond" then
            diamond = item
        end
    end
    print("总硬币价值：", coins)
    local tempCoins = 0
    for slot, coin in pairs(coinList) do
        local amount = coin.components.stackable.stacksize
        if coin.prefab == "taxue_coin" then
            tempCoins = tempCoins + amount * 100
        elseif coin.prefab == "taxue_coin_silver" then
            tempCoins = tempCoins + amount
        elseif coin.prefab == "taxue_coin_copper" then
            tempCoins = tempCoins + amount * 0.01
        end
    end

    --如果是银行模式并且有钻石,存银行
    if diamond and coins + tempCoins > 0 then
        container:RemoveItem(diamond):Remove()
        RemoveSlotsItems(container, coinList)
        GetPlayer().bank_value = GetPlayer().bank_value + (coins + tempCoins) / 100
        playSound = true
        --如果不是禁用,并且金额大于500梅币
    elseif cfg.SELL_PAVILION and coins + tempCoins >= 50000 then
        RemoveSlotsItems(container, coinList)
        local goldBrick = SpawnPrefab("gold_brick")
        goldBrick.taxue_coin_value = coins + tempCoins
        container:GiveItem(goldBrick)
        playSound = true
        --否则,生成梅币
    else
        local gold = math.floor(coins / 100)
        coins = coins - gold * 100
        local silver = math.floor(coins)
        local copper = math.floor((coins - silver) * 100 + 0.5)

        TaxueGiveItem(inst, "taxue_coin", gold)          --刷金币
        TaxueGiveItem(inst, "taxue_coin_silver", silver) --刷银币
        TaxueGiveItem(inst, "taxue_coin_copper", copper) --刷铜币

        if gold + silver + copper > 0 then
            playSound = true
        end
    end
    if playSound then inst.SoundEmitter:PlaySound("money/sfx/money") end
end

---开宝藏
---@param treasures table[]
---@return table loots
---@return table[] numbers
function OpenTreasures(treasures)
    treasures[1].SoundEmitter:PlaySound("dontstarve_DLC002/common/loot_reveal")

    local numbers = { {}, {} }

    local loots = { boneshard = 2 * #treasures }

    loots["obsidian"] = 0

    for _, treasure in pairs(treasures) do
        for i = 1, treasure.components.workable.workleft do
            if math.random() <= 0.2 then
                loots["obsidian"] = loots["obsidian"] + 1
            end
        end

        for _, entry in ipairs(LootTables[treasure.prefab]) do
            local prefab = entry[1]
            local chance = entry[2]
            if math.random() <= chance then
                loots[prefab] = loots[prefab] and loots[prefab] + 1 or 1
            end
        end

        local books = { "book_tentacles", "book_birds", "book_meteor", "book_sleep", "book_brimstone", "book_gardening",
            "book_tentacles", "book_birds", "book_meteor", "book_sleep", "book_brimstone" }                                --原版书籍
        local statues = { "ruins_statue_head", "ruins_statue_head_nogem", "ruins_statue_mage", "ruins_statue_mage_nogem" } --远古雕像
        if math.random() <= 0.1 then
            local book = books[math.random(#books)]
            loots[book] = loots[book] and loots[book] + 1 or 1
        end

        if treasure.prefab == "taxue_buriedtreasure_monster" then --怪物宝藏
            local str = treasure.advance_list[1] or "spider"
            local monster = SpawnPrefab(str)
            if monster then
                monster.Transform:SetPosition(treasure.Transform:GetWorldPosition())
            end
        else
            local chanceChest = 0
            local chanceStatue = 0
            local chest
            if treasure.prefab == "taxue_buriedtreasure" then
                chanceChest = 0.5
                chanceStatue = 0.2
                chest = "taxue_treasurechest"
            elseif treasure.prefab == "taxue_buriedtreasure_luxury" then
                chanceChest = 0.3
                chanceStatue = 0.3
                chest = "taxue_pandoraschest"
            end

            if math.random() <= chanceChest then
                numbers[2][chest] = numbers[2][chest] and numbers[2][chest] + 1 or 1
                if cfg.DESTORY_CHEST then
                    loots.boards = loots.boards and loots.boards + 1 or 1
                    for __, prefab in ipairs(treasure.advance_list) do
                        loots[prefab] = loots[prefab] and loots[prefab] + 1 or 1
                    end
                else
                    local chest = SpawnPrefab(chest)
                    for __, v in ipairs(treasure.advance_list) do
                        local item = SpawnPrefab(v)
                        if item ~= nil then
                            chest.components.container:GiveItem(item)
                        end
                    end
                    chest.Transform:SetPosition(treasure.Transform:GetWorldPosition())
                end
            elseif math.random() <= chanceStatue then
                numbers[2]["statue"] = numbers[2]["statue"] and numbers[2]["statue"] + 1 or 1
                local statue = SpawnPrefab(statues[math.random(#statues)])
                if cfg.DESTORY_STATUE then
                    local dorps = statue.components.lootdropper:GetAllLoot()
                    for _, prefab in ipairs(dorps) do
                        loots[prefab] = loots[prefab] and loots[prefab] + 1 or 1
                        statue:Remove()
                    end
                else
                    statue.Transform:SetPosition(treasure.Transform:GetWorldPosition()) --生成随机雕像
                end
            end
        end
        numbers[1][treasure.prefab] = numbers[1][treasure.prefab] and numbers[1][treasure.prefab] + 1 or 1
        treasure:Remove()
    end
    return loots, numbers
end

---开启所有宝藏并将物品添加进包裹
---@param package table
---@param treasures table[]
function AddTreasuresToPackage(package, treasures)
    local loots, numbers = OpenTreasures(treasures)
    for name, amount in pairs(loots) do
        local prefab = SpawnPrefab(name)
        if prefab and prefab.components.stackable then
            prefab.components.stackable.stacksize = amount
            AddItemToSuperPackage(package, prefab)
        else
            prefab:Remove()
            for _ = 1, amount do
                AddItemToSuperPackage(package, SpawnPrefab(name))
            end
        end
    end
    local str = "这波打包了:\n"
    for _, line in pairs(numbers) do
        for name, number in pairs(line) do
            local name = name == "statue" and "雕像" or TaxueToChs(name)
            str = str .. name .. number .. "个 "
        end
        str = str .. "\n"
    end
    package:AddComponent("talker")
    package.components.talker.colour = Vector3(255 / 255, 131 / 255, 250 / 255, 1)
    package.components.talker.offset = Vector3(0, 100, 0)
    package.components.talker:Say(str, 10)
    package:RemoveComponent("talker")
end
